<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>2D Range of Motion Tracking – Front, Left, & Right Views</title>
  <style>
    body{font-family:Arial, sans-serif;background:#f4f4f4;text-align:center;padding:20px}
    #tabSwitcher{margin-bottom:20px}
    #tabSwitcher button{margin:0 10px;padding:10px 20px;font-size:16px}
    #videoContainer{position:relative;width:640px;margin:0 auto 20px}
    #input_video{display:none}
    #output_canvas{width:640px;height:480px;border:2px solid #333;border-radius:8px;background:#000;margin-bottom:20px}
    .section{width:640px;margin:0 auto}
    .measurements{font-size:18px;margin-bottom:10px}
    .measurements div{margin:5px 0}
    .chartContainer{margin:10px 0}
    .controls{margin:10px 0}
    .controls button{margin:5px;padding:8px 12px;font-size:16px}
    .hidden{display:none}
  </style>
</head>
<body>
  <h1>2D Range of Motion Tracking – Front, Left, & Right Views</h1>

  <!-- Tab Switcher -->
  <div id="tabSwitcher">
    <button data-tab="front">Front View</button>
    <button data-tab="left">Left Side View</button>
    <button data-tab="right">Right Side View</button>
  </div>

  <!-- Video & Canvas -->
  <div id="videoContainer">
    <video id="input_video" autoplay playsinline></video>
    <canvas id="output_canvas"></canvas>
  </div>

  <!-- Front View -->
  <div id="frontSection" class="section">
    <h2>Front View Measurements</h2>
    <div class="measurements">
      <div id="leftHipAbd">Left Hip Abduction: --°</div>
      <div id="rightHipAbd">Right Hip Abduction: --°</div>
      <div id="leftShoulderFlex">Left Shoulder Flexion: --°</div>
      <div id="rightShoulderFlex">Right Shoulder Flexion: --°</div>
    </div>
    <div class="chartContainer">
      <canvas id="chartCanvasFront" width="640" height="300"></canvas>
    </div>
    <div class="controls">
      <button data-start="front">Start Recording</button>
      <button data-stop="front" disabled>Stop Recording</button>
      <button data-png="front">Download Graph</button>
      <button data-csv="front">Download CSV</button>
    </div>
  </div>

  <!-- Left Side -->
  <div id="leftSection" class="section hidden">
    <h2>Left Side View Measurements</h2>
    <div class="measurements">
      <div id="shoulderRotationLeft">Left Shoulder IR/ER: --°</div>
      <div id="leftKneeFlex">Left Knee Flexion: --°</div>
      <div id="leftAnkleAngle">Left Ankle Angle: --°</div>
    </div>
    <div class="chartContainer">
      <canvas id="chartCanvasLeft" width="640" height="300"></canvas>
    </div>
    <div class="controls">
      <button data-start="left">Start Recording</button>
      <button data-stop="left" disabled>Stop Recording</button>
      <button data-png="left">Download Graph</button>
      <button data-csv="left">Download CSV</button>
    </div>
  </div>

  <!-- Right Side -->
  <div id="rightSection" class="section hidden">
    <h2>Right Side View Measurements</h2>
    <div class="measurements">
      <div id="shoulderRotationRight">Right Shoulder IR/ER: --°</div>
      <div id="rightKneeFlex">Right Knee Flexion: --°</div>
      <div id="rightAnkleAngle">Right Ankle Angle: --°</div>
    </div>
    <div class="chartContainer">
      <canvas id="chartCanvasRight" width="640" height="300"></canvas>
    </div>
    <div class="controls">
      <button data-start="right">Start Recording</button>
      <button data-stop="right" disabled>Stop Recording</button>
      <button data-png="right">Download Graph</button>
      <button data-csv="right">Download CSV</button>
    </div>
  </div>

  <!-- External Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    // --------------- Helpers ---------------
    const byId = (id) => document.getElementById(id);
    const nowSec = (t0) => ((Date.now() - t0) / 1000).toFixed(2);

    // Throttle function for chart updates (default ~10 FPS)
    function throttle(fn, ms) {
      let last = 0;
      return (...args) => {
        const t = performance.now();
        if (t - last >= ms) {
          last = t;
          fn(...args);
        }
      };
    }

    // High-DPI canvas scaling for crisp lines and faster blits
    function resizeCanvasForDPR(canvas) {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return ctx;
    }

    // --------------- Tabs ---------------
    const sections = {
      front: byId('frontSection'),
      left: byId('leftSection'),
      right: byId('rightSection')
    };
    let activeTab = 'front';
    document.getElementById('tabSwitcher').addEventListener('click', (e) => {
      const tab = e.target.getAttribute('data-tab');
      if (!tab) return;
      activeTab = tab;
      Object.entries(sections).forEach(([k, el]) => el.classList.toggle('hidden', k !== tab));
    });

    // --------------- Video / Canvas ---------------
    const videoElement = byId('input_video');
    const canvasElement = byId('output_canvas');
    const canvasCtx = resizeCanvasForDPR(canvasElement);
    window.addEventListener('resize', () => resizeCanvasForDPR(canvasElement));

    // --------------- MediaPipe Pose ---------------
    const pose = new Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
    });
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    const camera = new Camera(videoElement, {
      onFrame: async () => { await pose.send({ image: videoElement }); },
      width: 640,
      height: 480
    });
    camera.start();

    // --------------- Drawing ---------------
    const POSE_CONNECTIONS = [
      [11,12],[11,13],[13,15],[12,14],[14,16],[11,23],[12,24],[23,24],[23,25],[25,27],[24,26],[26,28],[27,31],[28,32]
    ];

    function drawSkeleton(lm) {
      canvasCtx.lineWidth = 2;
      canvasCtx.strokeStyle = 'white';
      for (const [i, j] of POSE_CONNECTIONS) {
        const a = lm[i], b = lm[j];
        if (!a || !b) continue;
        canvasCtx.beginPath();
        canvasCtx.moveTo(a.x * canvasElement.width, a.y * canvasElement.height);
        canvasCtx.lineTo(b.x * canvasElement.width, b.y * canvasElement.height);
        canvasCtx.stroke();
      }
    }

    function drawLandmarks(lm) {
      const dot = (x, y) => { canvasCtx.beginPath(); canvasCtx.arc(x, y, 3, 0, 2 * Math.PI); canvasCtx.fillStyle = 'red'; canvasCtx.fill(); };

      // Nose only
      if (lm[0]) dot(lm[0].x * canvasElement.width, lm[0].y * canvasElement.height);

      // Left hand avg (17-19)
      if (lm.length > 19) {
        const idx = [17,18,19].filter(i => lm[i]);
        if (idx.length) {
          const ax = idx.reduce((s,i)=>s+lm[i].x,0)/idx.length;
          const ay = idx.reduce((s,i)=>s+lm[i].y,0)/idx.length;
          dot(ax * canvasElement.width, ay * canvasElement.height);
        }
      }
      // Right hand avg (20-22)
      if (lm.length > 22) {
        const idx = [20,21,22].filter(i => lm[i]);
        if (idx.length) {
          const ax = idx.reduce((s,i)=>s+lm[i].x,0)/idx.length;
          const ay = idx.reduce((s,i)=>s+lm[i].y,0)/idx.length;
          dot(ax * canvasElement.width, ay * canvasElement.height);
        }
      }
      // Other landmarks (skip face 1-10 and hands 17-22)
      lm.forEach((p, i) => {
        if (!p) return;
        if (i === 0) return;
        if (i >= 1 && i <= 10) return;
        if (i >= 17 && i <= 22) return;
        dot(p.x * canvasElement.width, p.y * canvasElement.height);
      });
    }

    // --------------- Math ---------------
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    function angle3pt(A,B,C){
      const ABx=A.x-B.x, ABy=A.y-B.y, CBx=C.x-B.x, CBy=C.y-B.y;
      const dot=ABx*CBx + ABy*CBy;
      const magAB=Math.hypot(ABx,ABy), magCB=Math.hypot(CBx,CBy);
      if (!magAB || !magCB) return 0;
      return Math.acos(clamp(dot/(magAB*magCB), -1, 1)) * 180/Math.PI;
    }
    function angleBetweenVectors(a,b){
      const dot=a.x*b.x + a.y*b.y;
      const magA=Math.hypot(a.x,a.y), magB=Math.hypot(b.x,b.y);
      if (!magA || !magB) return 0;
      return Math.acos(clamp(dot/(magA*magB), -1, 1)) * 180/Math.PI;
    }
    function signedAngleBetweenVectors(a,b){
      const cross=a.x*b.y - a.y*b.x, dot=a.x*b.x + a.y*b.y;
      return Math.atan2(cross, dot) * 180/Math.PI;
    }

    // --------------- Charts (one factory) ---------------
    function makeLineChart(canvasId, labelsRef, datasetsDef){
      const ctx = byId(canvasId).getContext('2d');
      return new Chart(ctx, {
        type:'line',
        data:{ labels: labelsRef, datasets: datasetsDef.map(d => ({...d, fill:false, tension:0.1})) },
        options:{
          animation:false,
          parsing:false,
          normalized:true,
          spanGaps:true,
          elements:{ point:{ radius:0 } },
          scales:{ x:{ title:{ display:true, text:'Time (s)' } }, y:{ title:{ display:true, text:'Angle (°)' } } }
        }
      });
    }

    // State for each view, with single time tick per frame when recording
    const views = {
      front: {
        time: [], data: {
          leftHipAbd: [], rightHipAbd: [], leftShoulderFlex: [], rightShoulderFlex: []
        },
        startTime: 0, recording:false, chart:null
      },
      left: {
        time: [], data: {
          shoulderRot: [], kneeFlex: [], ankle: []
        },
        startTime: 0, recording:false, chart:null
      },
      right: {
        time: [], data: {
          shoulderRot: [], kneeFlex: [], ankle: []
        },
        startTime: 0, recording:false, chart:null
      }
    };

    // Create charts
    views.front.chart = makeLineChart('chartCanvasFront', views.front.time, [
      {label:'Left Hip Abd',    data: views.front.data.leftHipAbd,    borderColor:'red'},
      {label:'Right Hip Abd',   data: views.front.data.rightHipAbd,   borderColor:'blue'},
      {label:'Left Shoulder Flex',  data: views.front.data.leftShoulderFlex,  borderColor:'green'},
      {label:'Right Shoulder Flex', data: views.front.data.rightShoulderFlex, borderColor:'orange'}
    ]);
    views.left.chart = makeLineChart('chartCanvasLeft', views.left.time, [
      {label:'Shoulder IR/ER', data: views.left.data.shoulderRot, borderColor:'purple'},
      {label:'Knee Flex',      data: views.left.data.kneeFlex,    borderColor:'red'},
      {label:'Ankle Angle',    data: views.left.data.ankle,       borderColor:'blue'}
    ]);
    views.right.chart = makeLineChart('chartCanvasRight', views.right.time, [
      {label:'Shoulder IR/ER', data: views.right.data.shoulderRot, borderColor:'purple'},
      {label:'Knee Flex',      data: views.right.data.kneeFlex,    borderColor:'red'},
      {label:'Ankle Angle',    data: views.right.data.ankle,       borderColor:'blue'}
    ]);

    const updateFrontChart = throttle(() => views.front.chart.update('none'), 100);
    const updateLeftChart  = throttle(() => views.left.chart.update('none'), 100);
    const updateRightChart = throttle(() => views.right.chart.update('none'), 100);

    // --------------- Recording / Downloads (generic) ---------------
    let mediaRecorder = null;
    let recordedChunks = [];
    function startRecording(viewKey, filename){
      const v = views[viewKey];
      // reset series and time together
      v.time.length = 0;
      Object.values(v.data).forEach(arr => arr.length = 0);
      v.recording = true;
      v.startTime = Date.now();

      const stream = canvasElement.captureStream(30);
      mediaRecorder = new MediaRecorder(stream, { mimeType:'video/webm' });
      recordedChunks = [];
      mediaRecorder.ondataavailable = (e) => { if (e.data.size) recordedChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type:'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = filename;
        document.body.appendChild(a); a.click();
        setTimeout(()=>{ document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
      };
      mediaRecorder.start();
      toggleButtons(viewKey, true);
    }
    function stopRecording(viewKey){
      const v = views[viewKey];
      v.recording = false;
      if (mediaRecorder) mediaRecorder.stop();
      toggleButtons(viewKey, false);
    }
    function toggleButtons(viewKey, recording){
      const startBtn = document.querySelector(`[data-start="${viewKey}"]`);
      const stopBtn  = document.querySelector(`[data-stop="${viewKey}"]`);
      startBtn.disabled = recording;
      stopBtn.disabled  = !recording;
    }
    function downloadPNG(viewKey, filename){
      const url = views[viewKey].chart.toBase64Image();
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
    }
    function downloadCSV(viewKey, headerMap, filename){
      const v = views[viewKey];
      const headers = ['Time'].concat(Object.keys(headerMap));
      let csv = headers.join(',') + '\n';
      for (let i=0; i<v.time.length; i++){
        const row = [v.time[i]];
        for (const key of Object.keys(headerMap)) {
          const arr = v.data[headerMap[key]];
          row.push(arr[i] ?? '');
        }
        csv += row.join(',') + '\n';
      }
      const a = document.createElement('a');
      a.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
      a.download = filename;
      a.click();
    }

    // Event delegation for all control buttons
    document.body.addEventListener('click', (e) => {
      const start = e.target.getAttribute('data-start');
      const stop  = e.target.getAttribute('data-stop');
      const png   = e.target.getAttribute('data-png');
      const csv   = e.target.getAttribute('data-csv');

      if (start) {
        startRecording(start, `${start}_view_recording.webm`);
      } else if (stop) {
        stopRecording(stop);
      } else if (png) {
        downloadPNG(png, `${png}_view_graph.png`);
      } else if (csv) {
        if (csv === 'front') {
          downloadCSV('front', {
            'Left Hip Abd':'leftHipAbd',
            'Right Hip Abd':'rightHipAbd',
            'Left Shoulder Flex':'leftShoulderFlex',
            'Right Shoulder Flex':'rightShoulderFlex'
          }, 'front_view_data.csv');
        } else if (csv === 'left') {
          downloadCSV('left', {
            'Shoulder IR/ER':'shoulderRot',
            'Knee Flex':'kneeFlex',
            'Ankle Angle':'ankle'
          }, 'left_view_data.csv');
        } else if (csv === 'right') {
          downloadCSV('right', {
            'Shoulder IR/ER':'shoulderRot',
            'Knee Flex':'kneeFlex',
            'Ankle Angle':'ankle'
          }, 'right_view_data.csv');
        }
      }
    });

    // --------------- Pose Results ---------------
    pose.onResults((results) => {
      // canvas draw
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      const lm = results.poseLandmarks;
      if (lm) {
        drawLandmarks(lm);
        drawSkeleton(lm);

        const L = {
          shoulder: lm[11], elbow: lm[13], wrist: lm[15],
          hip: lm[23], knee: lm[25], ankle: lm[27]
        };
        const R = {
          shoulder: lm[12], elbow: lm[14], wrist: lm[16],
          hip: lm[24], knee: lm[26], ankle: lm[28]
        };

        // ------- Front view metrics (UI always updates; log only if recording) -------
        if (L.hip && L.knee) {
          const vertical = { x:0, y:1 };
          const thigh = { x: L.knee.x - L.hip.x, y: L.knee.y - L.hip.y };
          const a = angleBetweenVectors(thigh, vertical);
          byId('leftHipAbd').innerText = `Left Hip Abduction: ${a.toFixed(1)}°`;
          if (views.front.recording) views.front.data.leftHipAbd.push(a);
        }
        if (R.hip && R.knee) {
          const vertical = { x:0, y:1 };
          const thigh = { x: R.knee.x - R.hip.x, y: R.knee.y - R.hip.y };
          const a = angleBetweenVectors(thigh, vertical);
          byId('rightHipAbd').innerText = `Right Hip Abduction: ${a.toFixed(1)}°`;
          if (views.front.recording) views.front.data.rightHipAbd.push(a);
        }
        if (L.shoulder && L.elbow) {
          const verticalRef = { x: L.shoulder.x, y: L.shoulder.y + 0.1 };
          const a = angle3pt(verticalRef, L.shoulder, L.elbow);
          byId('leftShoulderFlex').innerText = `Left Shoulder Flexion: ${a.toFixed(1)}°`;
          if (views.front.recording) views.front.data.leftShoulderFlex.push(a);
        }
        if (R.shoulder && R.elbow) {
          const verticalRef = { x: R.shoulder.x, y: R.shoulder.y + 0.1 };
          const a = angle3pt(verticalRef, R.shoulder, R.elbow);
          byId('rightShoulderFlex').innerText = `Right Shoulder Flexion: ${a.toFixed(1)}°`;
          if (views.front.recording) views.front.data.rightShoulderFlex.push(a);
        }

        // If recording, push ONE time tick per frame for that view (keeps arrays aligned)
        if (views.front.recording) {
          views.front.time.push(nowSec(views.front.startTime));
          updateFrontChart();
        }

        // ------- Left view -------
        if (L.shoulder && L.elbow && L.wrist) {
          const upper = { x: L.elbow.x - L.shoulder.x, y: L.elbow.y - L.shoulder.y };
          const fore  = { x: L.wrist.x - L.elbow.x,    y: L.wrist.y - L.elbow.y };
          const raw = signedAngleBetweenVectors(upper, fore);
          const rot = raw - 90;
          byId('shoulderRotationLeft').innerText = `Left Shoulder IR/ER: ${rot.toFixed(1)}°`;
          if (views.left.recording) views.left.data.shoulderRot.push(rot);
        }
        if (L.hip && L.knee && L.ankle) {
          const k = angle3pt(L.hip, L.knee, L.ankle);
          byId('leftKneeFlex').innerText = `Left Knee Flexion: ${k.toFixed(1)}°`;
          if (views.left.recording) views.left.data.kneeFlex.push(k);
        }
        if (L.knee && L.ankle) {
          const ref = { x:L.ankle.x, y:L.ankle.y + 0.1 };
          const a = angle3pt(L.knee, L.ankle, ref);
          byId('leftAnkleAngle').innerText = `Left Ankle Angle: ${a.toFixed(1)}°`;
          if (views.left.recording) views.left.data.ankle.push(a);
        }
        if (views.left.recording) {
          views.left.time.push(nowSec(views.left.startTime));
          updateLeftChart();
        }

        // ------- Right view -------
        if (R.shoulder && R.elbow && R.wrist) {
          const upper = { x: R.elbow.x - R.shoulder.x, y: R.elbow.y - R.shoulder.y };
          const fore  = { x: R.wrist.x - R.elbow.x,    y: R.wrist.y - R.elbow.y };
          const raw = signedAngleBetweenVectors(upper, fore);
          const rot = raw - 90;
          byId('shoulderRotationRight').innerText = `Right Shoulder IR/ER: ${rot.toFixed(1)}°`;
          if (views.right.recording) views.right.data.shoulderRot.push(rot);
        }
        if (R.hip && R.knee && R.ankle) {
          const k = angle3pt(R.hip, R.knee, R.ankle);
          byId('rightKneeFlex').innerText = `Right Knee Flexion: ${k.toFixed(1)}°`;
          if (views.right.recording) views.right.data.kneeFlex.push(k);
        }
        if (R.knee && R.ankle) {
          const ref = { x:R.ankle.x, y:R.ankle.y + 0.1 };
          const a = angle3pt(R.knee, R.ankle, ref);
          byId('rightAnkleAngle').innerText = `Right Ankle Angle: ${a.toFixed(1)}°`;
          if (views.right.recording) views.right.data.ankle.push(a);
        }
        if (views.right.recording) {
          views.right.time.push(nowSec(views.right.startTime));
          updateRightChart();
        }

      }
      canvasCtx.restore();
    });

    // --------------- Optional micro-tweaks ---------------
    // Reduce console noise
    // console.log is off by default; re-enable only for debugging
    // console.log("Pose ready");
  </script>
</body>
</html>
